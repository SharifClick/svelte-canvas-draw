{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\CanvasDraw.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n  import { onMount, afterUpdate, onDestroy  } from \"svelte\";\r\n  import { LazyBrush } from \"lazy-brush\";\r\n  import { Catenary } from \"catenary-curve\";\r\n\r\n  import ResizeObserver from \"resize-observer-polyfill\";\r\n\r\n  export let onChange = null;\r\n  export let loadTimeOffset = 5;\r\n  export let lazyRadius = 12;\r\n  export let brushRadius = 10;\r\n  export let brushColor = \"#444\";\r\n  export let catenaryColor = \"#0a0302\";\r\n  export let gridColor = \"rgba(150,150,150,0.17)\";\r\n  export let backgroundColor = \"#FFF\";\r\n  export let hideGrid = false;\r\n  export let canvasWidth = 800;\r\n  export let canvasHeight = 800;\r\n  export let disabled = false;\r\n  export let imgSrc = \"\";\r\n  export let saveData = \"\";\r\n  export let immediateLoading = false;\r\n  export let hideInterface = false;\r\n  export let classes = '';\r\n\r\n\r\n  function midPointBtw(p1, p2) {\r\n      return {\r\n        x: p1.x + (p2.x - p1.x) / 2,\r\n        y: p1.y + (p2.y - p1.y) / 2\r\n      };\r\n    }\r\n\r\n  const canvasStyle = {\r\n    display: \"block\",\r\n    position: \"absolute\"\r\n  };\r\n\r\n  const canvasTypes = [\r\n    {\r\n      name: \"interface\",\r\n      zIndex: 15\r\n    },\r\n    {\r\n      name: \"drawing\",\r\n      zIndex: 11\r\n    },\r\n    {\r\n      name: \"temp\",\r\n      zIndex: 12\r\n    },\r\n    {\r\n      name: \"grid\",\r\n      zIndex: 10\r\n    }\r\n  ];\r\n\r\n\r\n   let canvas = {};\r\n   let ctx = {};\r\n\r\n   let catenary = new Catenary();\r\n\r\n   let points = [];\r\n   let lines = [];\r\n\r\n   let mouseHasMoved = true;\r\n   let valuesChanged = true;\r\n   let isDrawing = false;\r\n   let isPressing = false;\r\n   let lazy = null;\r\n   let image = null;\r\n   let chainLength = null;\r\n\r\n   let canvasContainer = null;\r\n   let canvasObserver = null;\r\n\r\n\r\n\r\n\r\n   onMount(() => {\r\n\r\n    Object.keys(canvas).forEach((key) => {\r\n      ctx[key] = canvas[key].getContext(\"2d\");\r\n     })\r\n\r\n    console.log(ctx)\r\n\r\n     lazy = new LazyBrush({\r\n       radius: lazyRadius * window.devicePixelRatio,\r\n      enabled: true,\r\n      initialPoint: {\r\n        x: window.innerWidth / 2,\r\n        y: window.innerHeight / 2\r\n      }\r\n    });\r\n    chainLength = lazyRadius * window.devicePixelRatio;\r\n\r\n    canvasObserver = new ResizeObserver((entries, observer) =>\r\n      handleCanvasResize(entries, observer)\r\n    );\r\n    canvasObserver.observe(canvasContainer);\r\n\r\n    drawImage();\r\n    loop();\r\n\r\n    window.setTimeout(() => {\r\n      const initX = window.innerWidth / 2;\r\n      const initY = window.innerHeight / 2;\r\n      lazy.update(\r\n        { x: initX - chainLength / 4, y: initY },\r\n        { both: true }\r\n      );\r\n      lazy.update(\r\n        { x: initX + chainLength / 4, y: initY },\r\n        { both: false }\r\n      );\r\n      mouseHasMoved = true;\r\n      valuesChanged = true;\r\n      clear();\r\n\r\n      // Load saveData from prop if it exists\r\n      if (saveData) {\r\n        loadSaveData(saveData);\r\n      }\r\n    }, 100);\r\n\r\n  });\r\n\r\n\r\n  // afterUpdate(() => {\r\n  //   // Set new lazyRadius values\r\n  //   chainLength = lazyRadius * window.devicePixelRatio;\r\n  //   lazy.setRadius(lazyRadius * window.devicePixelRatio);\r\n  //   loadSaveData(saveData);\r\n  //   // Signal loop function that values changed\r\n  //   valuesChanged = true;\r\n\r\n  // });\r\n\r\n\r\n\r\n  // onDestroy(() => {\r\n  //   canvasObserver.unobserve(canvasContainer)\r\n  // });\r\n\r\n\r\n\r\n  let drawImage = () => {\r\n    if (!imgSrc) return;\r\n    image = new Image();\r\n    image.crossOrigin = \"anonymous\";\r\n    image.onload = () => drawImage({ ctx: ctx.grid, img: image });\r\n    image.src = imgSrc;\r\n  };\r\n\r\n  let undo = () => {\r\n    const lines = lines.slice(0, -1);\r\n    clear();\r\n    simulateDrawingLines({ lines, immediate: true });\r\n    triggerOnChange();\r\n  };\r\n\r\n  let getSaveData = () => {\r\n    return JSON.stringify({\r\n      lines: lines,\r\n      width: canvasWidth,\r\n      height: canvasHeight\r\n    });\r\n  };\r\n\r\n  let loadSaveData = (saveData, immediate = immediateLoading) => {\r\n    console.log(saveData)\r\n    if (typeof saveData !== \"string\") {\r\n      throw new Error(\"saveData needs to be of type string!\");\r\n    }\r\n\r\n    const { lines, width, height } = JSON.parse(saveData);\r\n\r\n    if (!lines || typeof lines.push !== \"function\") {\r\n      throw new Error(\"saveData.lines needs to be an array!\");\r\n    }\r\n\r\n    clear();\r\n\r\n    if (width === canvasWidth && height === canvasHeight) {\r\n      simulateDrawingLines({\r\n        lines,\r\n        immediate\r\n      });\r\n    } else {\r\n      const scaleX = canvasWidth / width;\r\n      const scaleY = canvasHeight / height;\r\n      const scaleAvg = (scaleX + scaleY) / 2;\r\n\r\n      simulateDrawingLines({\r\n        lines: lines.map(line => ({\r\n          ...line,\r\n          points: line.points.map(p => ({\r\n            x: p.x * scaleX,\r\n            y: p.y * scaleY\r\n          })),\r\n          brushRadius: line.brushRadius * scaleAvg\r\n        })),\r\n        immediate\r\n      });\r\n    }\r\n  };\r\n\r\n\r\n  let simulateDrawingLines = ({ lines, immediate }) => {\r\n    // Simulate live-drawing of the loaded lines\r\n    // TODO use a generator\r\n    let curTime = 0;\r\n    let timeoutGap = immediate ? 0 : loadTimeOffset;\r\n\r\n    lines.forEach(line => {\r\n      const { points, brushColor, brushRadius } = line;\r\n\r\n      // Draw all at once if immediate flag is set, instead of using setTimeout\r\n      if (immediate) {\r\n        // Draw the points\r\n        drawPoints({\r\n          points,\r\n          brushColor,\r\n          brushRadius\r\n        });\r\n\r\n        // Save line with the drawn points\r\n        points = points;\r\n        saveLine({ brushColor, brushRadius });\r\n        return;\r\n      }\r\n\r\n      // Use timeout to draw\r\n      for (let i = 1; i < points.length; i++) {\r\n        curTime += timeoutGap;\r\n        window.setTimeout(() => {\r\n          drawPoints({\r\n            points: points.slice(0, i + 1),\r\n            brushColor,\r\n            brushRadius\r\n          });\r\n        }, curTime);\r\n      }\r\n\r\n      curTime += timeoutGap;\r\n      window.setTimeout(() => {\r\n        // Save this line with its props instead of props\r\n        points = points;\r\n        saveLine({ brushColor, brushRadius });\r\n      }, curTime);\r\n    });\r\n  };\r\n\r\n  let handleDrawStart = e => {\r\n    e.preventDefault();\r\n\r\n    // Start drawing\r\n    isPressing = true;\r\n\r\n    const { x, y } = getPointerPos(e);\r\n\r\n    if (e.touches && e.touches.length > 0) {\r\n      // on touch, set catenary position to touch pos\r\n      lazy.update({ x, y }, { both: true });\r\n    }\r\n\r\n    // Ensure the initial down position gets added to our line\r\n    handlePointerMove(x, y);\r\n  };\r\n\r\n  let handleDrawMove = e => {\r\n    e.preventDefault();\r\n\r\n    const { x, y } = getPointerPos(e);\r\n    handlePointerMove(x, y);\r\n  };\r\n\r\n  let handleDrawEnd = e => {\r\n    e.preventDefault();\r\n\r\n    // Draw to this end pos\r\n    handleDrawMove(e);\r\n\r\n    // Stop drawing & save the drawn line\r\n    isDrawing = false;\r\n    isPressing = false;\r\n    saveLine();\r\n  };\r\n\r\n  let handleCanvasResize = (entries, observer) => {\r\n    const saveData = getSaveData();\r\n    for (const entry of entries) {\r\n      console.log(entry)\r\n      const { width, height } = entry.contentRect;\r\n      setCanvasSize(canvas.interface, width, height);\r\n      setCanvasSize(canvas.drawing, width, height);\r\n      setCanvasSize(canvas.temp, width, height);\r\n      setCanvasSize(canvas.grid, width, height);\r\n\r\n      drawGrid(ctx.grid);\r\n      drawImage();\r\n      loop({ once: true });\r\n    }\r\n    loadSaveData(saveData, true);\r\n  };\r\n\r\n  let setCanvasSize = (canvas, width, height) => {\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    canvas.style.width = width;\r\n    canvas.style.height = height;\r\n  };\r\n\r\n  let getPointerPos = e => {\r\n    const rect = canvas.interface.getBoundingClientRect();\r\n\r\n    // use cursor pos as default\r\n    let clientX = e.clientX;\r\n    let clientY = e.clientY;\r\n\r\n    // use first touch if available\r\n    if (e.changedTouches && e.changedTouches.length > 0) {\r\n      clientX = e.changedTouches[0].clientX;\r\n      clientY = e.changedTouches[0].clientY;\r\n    }\r\n\r\n    // return mouse/touch position inside canvas\r\n    return {\r\n      x: clientX - rect.left,\r\n      y: clientY - rect.top\r\n    };\r\n  };\r\n\r\n  let handlePointerMove = (x, y) => {\r\n    if (disabled) return;\r\n\r\n    lazy.update({ x, y });\r\n    const isDisabled = !lazy.isEnabled();\r\n\r\n    if (\r\n      (isPressing && !isDrawing) ||\r\n      (isDisabled && isPressing)\r\n    ) {\r\n      // Start drawing and add point\r\n      isDrawing = true;\r\n      points.push(lazy.brush.toObject());\r\n    }\r\n\r\n    if (isDrawing) {\r\n      // Add new point\r\n      points.push(lazy.brush.toObject());\r\n\r\n      // Draw current points\r\n      drawPoints({\r\n        points: points,\r\n        brushColor: brushColor,\r\n        brushRadius: brushRadius\r\n      });\r\n    }\r\n\r\n    mouseHasMoved = true;\r\n  };\r\n\r\n  let drawPoints = ({ points, brushColor, brushRadius }) => {\r\n    ctx.temp.lineJoin = \"round\";\r\n    ctx.temp.lineCap = \"round\";\r\n    ctx.temp.strokeStyle = brushColor;\r\n\r\n    ctx.temp.clearRect(\r\n      0,\r\n      0,\r\n      ctx.temp.canvas.width,\r\n      ctx.temp.canvas.height\r\n    );\r\n    ctx.temp.lineWidth = brushRadius * 2;\r\n\r\n    let p1 = points[0];\r\n    let p2 = points[1];\r\n\r\n    ctx.temp.moveTo(p2.x, p2.y);\r\n    ctx.temp.beginPath();\r\n\r\n    for (var i = 1, len = points.length; i < len; i++) {\r\n      // we pick the point between pi+1 & pi+2 as the\r\n      // end point and p1 as our control point\r\n      var midPoint = midPointBtw(p1, p2);\r\n      ctx.temp.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\r\n      p1 = points[i];\r\n      p2 = points[i + 1];\r\n    }\r\n    // Draw last line as a straight line while\r\n    // we wait for the next point to be able to calculate\r\n    // the bezier control point\r\n    ctx.temp.lineTo(p1.x, p1.y);\r\n    ctx.temp.stroke();\r\n  };\r\n\r\n  let saveLine = ({ brushColor, brushRadius } = {}) => {\r\n    if (points.length < 2) return;\r\n\r\n    // Save as new line\r\n    lines.push({\r\n      points: [...points],\r\n      brushColor: brushColor || brushColor,\r\n      brushRadius: brushRadius || brushRadius\r\n    });\r\n\r\n    // Reset points array\r\n    points.length = 0;\r\n\r\n    const width = canvas.temp.width;\r\n    const height = canvas.temp.height;\r\n\r\n    // Copy the line to the drawing canvas\r\n    ctx.drawing.drawImage(canvas.temp, 0, 0, width, height);\r\n\r\n    // Clear the temporary line-drawing canvas\r\n    ctx.temp.clearRect(0, 0, width, height);\r\n\r\n    triggerOnChange();\r\n  };\r\n\r\n  // let triggerOnChange = () => {\r\n  //   onChange && onChange(this);\r\n  // };\r\n\r\n  let clear = () => {\r\n    lines = [];\r\n    valuesChanged = true;\r\n    ctx.drawing.clearRect(\r\n      0,\r\n      0,\r\n      canvas.drawing.width,\r\n      canvas.drawing.height\r\n    );\r\n    ctx.temp.clearRect(\r\n      0,\r\n      0,\r\n      canvas.temp.width,\r\n      canvas.temp.height\r\n    );\r\n  };\r\n\r\n  let loop = ({ once = false } = {}) => {\r\n    if (mouseHasMoved || valuesChanged) {\r\n      const pointer = lazy.getPointerCoordinates();\r\n      const brush = lazy.getBrushCoordinates();\r\n\r\n      drawInterface(ctx.interface, pointer, brush);\r\n      mouseHasMoved = false;\r\n      valuesChanged = false;\r\n    }\r\n\r\n    if (!once) {\r\n      window.requestAnimationFrame(() => {\r\n        loop();\r\n      });\r\n    }\r\n  };\r\n\r\n  let drawGrid = ctx => {\r\n    if (hideGrid) return;\r\n\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    ctx.beginPath();\r\n    ctx.setLineDash([5, 1]);\r\n    ctx.setLineDash([]);\r\n    ctx.strokeStyle = gridColor;\r\n    ctx.lineWidth = 0.5;\r\n\r\n    const gridSize = 25;\r\n\r\n    let countX = 0;\r\n    while (countX < ctx.canvas.width) {\r\n      countX += gridSize;\r\n      ctx.moveTo(countX, 0);\r\n      ctx.lineTo(countX, ctx.canvas.height);\r\n    }\r\n    ctx.stroke();\r\n\r\n    let countY = 0;\r\n    while (countY < ctx.canvas.height) {\r\n      countY += gridSize;\r\n      ctx.moveTo(0, countY);\r\n      ctx.lineTo(ctx.canvas.width, countY);\r\n    }\r\n    ctx.stroke();\r\n  };\r\n\r\n  let drawInterface = (ctx, pointer, brush) => {\r\n    if (hideInterface) return;\r\n\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n\r\n    // Draw brush preview\r\n    ctx.beginPath();\r\n    ctx.fillStyle = brushColor;\r\n    ctx.arc(brush.x, brush.y, brushRadius, 0, Math.PI * 2, true);\r\n    ctx.fill();\r\n\r\n    // Draw mouse point (the one directly at the cursor)\r\n    ctx.beginPath();\r\n    ctx.fillStyle = catenaryColor;\r\n    ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI * 2, true);\r\n    ctx.fill();\r\n\r\n    // Draw catenary\r\n    if (lazy.isEnabled()) {\r\n      ctx.beginPath();\r\n      ctx.lineWidth = 2;\r\n      ctx.lineCap = \"round\";\r\n      ctx.setLineDash([2, 4]);\r\n      ctx.strokeStyle = catenaryColor;\r\n      // catenary.drawToCanvas(\r\n      //   ctx.interface,\r\n      //   brush,\r\n      //   pointer,\r\n      //   chainLength\r\n      // );\r\n      ctx.stroke();\r\n    }\r\n\r\n    // Draw brush point (the one in the middle of the brush preview)\r\n    ctx.beginPath();\r\n    ctx.fillStyle = catenaryColor;\r\n    ctx.arc(brush.x, brush.y, 2, 0, Math.PI * 2, true);\r\n    ctx.fill();\r\n  };\r\n\r\n\r\n\r\n</script>\r\n<style>\r\n  .drwaing-container{\r\n    display: block;\r\n    touch-action: none;\r\n  }\r\n\r\n\r\n</style>\r\n\r\n  <div\r\n    class=\"drwaing-container {classes}\"\r\n    style=\"height:{canvasHeight}px; width:{canvasWidth}px; background-color:{backgroundColor}\"\r\n    bind:this={canvasContainer}>\r\n    {#each canvasTypes as {name, zIndex}}\r\n      <canvas\r\n        key={name}\r\n        style=\"display:block;position:absolute; z-index:{zIndex}\"\r\n        bind:this={canvas[name]}\r\n        on:mousedown={name === \"interface\" ? handleDrawStart : undefined}\r\n        on:mousemove={name === \"interface\" ? handleDrawMove : undefined}\r\n        on:mouseup={name === \"interface\" ? handleDrawEnd : undefined}\r\n        on:mouseout={name === \"interface\" ? handleDrawEnd : undefined}\r\n        on:touchstart={name === \"interface\" ? handleDrawStart : undefined}\r\n        on:touchmove={name === \"interface\" ? handleDrawMove : undefined}\r\n        on:touchend={name === \"interface\" ? handleDrawEnd : undefined}\r\n        on:touchcancel={name === \"interface\" ? handleDrawEnd : undefined}\r\n      />\r\n    {/each}\r\n  </div>\r\n"
  ],
  "names": [],
  "mappings": "AAwhBE,gCAAkB,CAAC,AACjB,OAAO,CAAE,KAAK,CACd,YAAY,CAAE,IAAI,AACpB,CAAC"
}